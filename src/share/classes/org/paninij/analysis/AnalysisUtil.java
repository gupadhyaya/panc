package org.paninij.analysis;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.TreeSet;

import javax.lang.model.element.ElementKind;

import com.sun.tools.javac.code.Flags;
import com.sun.tools.javac.code.Symbol;
import com.sun.tools.javac.code.Type;
import com.sun.tools.javac.code.Symbol.ClassSymbol;
import com.sun.tools.javac.code.Symbol.MethodSymbol;
import com.sun.tools.javac.tree.JCTree;
import com.sun.tools.javac.tree.JCTree.*;
import com.sun.tools.javac.util.List;

public class AnalysisUtil {
	public static boolean shouldAnalyze(JCCapsuleDecl capsule,
			JCMethodDecl meth) {
		if ((meth.mods.flags & Flags.PRIVATE) != 0 ||
				// an active Capsule.
				activeRun(capsule.sym, meth.sym)) {
			return true;
		}
		return false;
	}

	public static boolean activeRun(ClassSymbol cs, MethodSymbol meth) {
		return (cs.capsule_info.definedRun &&
				meth.toString().compareTo("run()") == 0);
	}

	public static boolean activeThread(ClassSymbol cs, String tree_name) {
		return cs.capsule_info.definedRun && tree_name.indexOf("$") == -1;
	}

	/* Check whether a method is the input method is declared in the source
	 * code or generated by the compiler. */
	public static boolean originalMethod(ClassSymbol cs, JCMethodDecl meth,
			String tree_name) {
		String capsule_name = cs.toString();
		return (capsule_name.substring(capsule_name.indexOf("$")
				+ 1).compareTo("thread") == 0) &&
				(tree_name.indexOf("$Original()") != -1 ||
						(meth.mods.flags & Flags.PRIVATE) != 0);
	}

	public static JCExpression getEssentialExpr(JCExpression original) {
		JCExpression rightOp = original;
		while (rightOp instanceof JCTypeCast || rightOp instanceof JCParens) {
			if (rightOp instanceof JCTypeCast) {
				rightOp = ((JCTypeCast)rightOp).expr;
			} else if (rightOp instanceof JCParens) {
				rightOp = ((JCParens)rightOp).expr;
			}
		}
		return rightOp;
	}

	public static String rmDollar(String input) {
		int index = input.indexOf("$");

		if (index != -1) {
			return input.substring(0, index);
		}
		return input;
	}

	public static boolean isVarThis(JCTree that) {
		if (that instanceof JCIdent) {
			JCIdent tree = (JCIdent)that;
			Symbol sym = tree.sym;
			if (sym != null) {
				ElementKind symKind = sym.getKind();
				if (symKind == ElementKind.FIELD) {
					if (sym.name.toString().compareTo("this") == 0) {
						return true;
					}
				}
			}
		}
		return false;
	}

	// Check whether a symbol is field that is declared in inside a Capsule.
	public static boolean isInnerField(List<JCTree> defs, Symbol s) {
		for (JCTree def : defs) {
			if (def instanceof JCVariableDecl) {
				JCVariableDecl field = (JCVariableDecl)def;
				if (field.sym == s /* &&
						((field.mods.flags & Flags.PRIVATE) != 0) */
						&& (field.mods.flags == 0)) {
					return s.getKind() == ElementKind.FIELD;
				}
			}
		}
		return false;
	}

	public static void addCallEdge(Symbol caller, Symbol callee,
			HashMap<Symbol, HashSet<Symbol>> reversed) {
		HashSet<Symbol> callers = reversed.get(callee);
		if (callers == null) {
			callers = new HashSet<Symbol>();
			reversed.put(callee, callers);
		}
		callers.add(caller);
	}

	// The following two methods are for constructing the order for the for the
	// analysis for methods.
	public static Collection<JCTree> constructWorklist(ArrayList<JCTree> order) {
		return new TreeSet<JCTree>(new InnerComparator(order));
	}

	private static class InnerComparator implements Comparator<JCTree> {
		public final ArrayList<JCTree> order;

		public InnerComparator(ArrayList<JCTree> order) {
			this.order = order;
		}

		public int compare(JCTree o1, JCTree o2) {
			int i1 = order.indexOf(o1);
			int i2 = order.indexOf(o2);
			return i1 - i2;
		}
	}

	public static boolean immute_type(Type type) {
		String type_string = type.toString();
		return type_string.compareTo("java.lang.String") == 0 ||
			type_string.compareTo("java.math.BigDecimal") == 0;
	}
}
